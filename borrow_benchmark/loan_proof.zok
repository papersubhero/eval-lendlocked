from "ecc/babyjubjubParams" import BabyJubJubParams;
import "signatures/verifyEddsa.code" as verifyEddsa;
import "ecc/babyjubjubParams.code" as context;
import "hashes/pedersen/512bit" as hash;
// to convert the input preimage into the correct format u32[16]
import "hashes/utils/256bitsDirectionHelper" as multiplex;

// leave the root out of the struct as all the variables 
// in the struct are all private and the root is public
struct MerkleTreeProofStruct<DEPTH> {
	u32[8] leaf;
	bool[DEPTH] directionSelector; 
	u32[DEPTH][8] path;
}

// Merkle-Tree inclusion proof for tree depth <DEPTH> using sha256
def merkleTreeProof<DEPTH>(u32[8] root, MerkleTreeProofStruct<DEPTH> proof) -> bool {
    // Start from the leaf
    u32[8] mut digest = proof.leaf;

	// Loop up the tree
	for u32 i in 0..DEPTH {
		u32[16] preimage = multiplex(proof.directionSelector[i], digest, proof.path[i]);
		digest = hash(preimage);
	}

    return digest == root;
}

const u32 TREE_DEPTH = 10;

// put merkle tree witness after the witness of signature
def main(private field[2] R, private field S, field[2] A, u32[8] M0, u32[8] M1, u32[8] treeRootone, private MerkleTreeProofStruct<TREE_DEPTH> proofone, u32[8] treeRoottwo, private MerkleTreeProofStruct<TREE_DEPTH> prooftwo, u32[8] treeRootthree, private MerkleTreeProofStruct<TREE_DEPTH> proofthree){
  // context necessary for the signature verification
  BabyJubJubParams context = context();
  //Verify Signature (R,S) with PupKey (A) on Hash (M0, M1);
  bool isVerified = verifyEddsa(R, S, A, M0, M1, context);
  // both conditions must be true
  assert(isVerified == true);
  // first proof on length at most 10
  assert(merkleTreeProof(treeRootone, proofone));
  // second proof on length at most 10
  assert(merkleTreeProof(treeRoottwo, prooftwo));
  // third proof on length at most 10
  assert(merkleTreeProof(treeRootthree, proofthree));
  return;
}